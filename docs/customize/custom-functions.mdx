---
title: "Custom Functions"
description: "Extend default agent and write custom function calls"
icon: "function"
---

## Basic Function Registration

Functions can be either `sync` or `async`. Keep them focused and single-purpose.

```python
from browser_use import Controller, ActionResult
# Initialize the controller
controller = Controller()

@controller.action('Ask user for information', domains=['https://difficult.example.com'])   # pass domains= or page_filter= to limit actions to certain pages
def ask_human(question: str) -> ActionResult:
    answer = input(f'\n{question}\nInput: ')
    return ActionResult(extracted_content=answer)
```

<Note>
  Basic `Controller` has all basic functionality you might need to interact with
  the browser already implemented.
</Note>

```python
# ... then pass controller to the agent
agent = Agent(
    task=task,
    llm=llm,
    controller=controller
)
```

<Note>
  Keep the function name and description short and concise. The Agent use the
  function solely based on the name and description. The stringified output of
  the action is passed to the Agent.
</Note>

## Browser-Aware Functions

For actions that need browser access, add special parameters after your action parameters. The framework will automatically inject these:

### Available Special Parameters
- `browser_session: BrowserSession` - The current browser session
- `page: Page` - The current Playwright page (shortcut for `browser_session.get_current_page()`)
- `context: AgentContext` - Full agent context including history
- `page_extraction_llm: BaseChatModel` - LLM instance for page content extraction
- `available_file_paths: list[str]` - List of available file paths
- `has_sensitive_data: bool` - Whether the page contains sensitive data

```python
from playwright.async_api import Page
from browser_use import Controller, ActionResult

controller = Controller()

@controller.action('Open website')
async def open_website(url: str, page: Page) -> ActionResult:
    await page.goto(url)
    return ActionResult(extracted_content='Website opened')
```
```python
from browser_use import BrowserSession, Controller, ActionResult

controller = Controller()

@controller.action('Open website')
async def open_website(url: str, browser_session: BrowserSession) -> ActionResult:
    page = await browser_session.get_current_page()
    await page.goto(url)
    return ActionResult(extracted_content='Website opened')
```

## Structured Parameters with Pydantic

For complex actions, define parameter schemas using Pydantic models. When using `param_model`, your function should accept the model as its first parameter:

```python
from pydantic import BaseModel
from typing import Optional
from browser_use import Controller, ActionResult, BrowserSession

controller = Controller()

class JobDetails(BaseModel):
    title: str
    company: str
    job_link: str
    salary: Optional[str] = None

@controller.action(
    'Save job details which you found on page',
    param_model=JobDetails
)
async def save_job(params: JobDetails, browser_session: BrowserSession) -> ActionResult:
    print(f"Saving job: {params.title} at {params.company}")

    # Access browser if needed
    page = await browser_session.get_current_page()
    await page.goto(params.job_link)
    
    return ActionResult(extracted_content=f"Saved job: {params.title}")
```

## Action Definition Patterns

Browser Use supports two patterns for defining actions:

### Pattern 1: Pydantic Model First (Recommended for complex parameters)
When using `param_model`, your function receives the model instance as the first parameter:

```python
class MyParams(BaseModel):
    field1: str
    field2: int

@controller.action('My action', param_model=MyParams)
def my_action(params: MyParams, page: Page) -> ActionResult:
    # params contains all action parameters
    return ActionResult(extracted_content=f"Processed {params.field1}")
```

### Pattern 2: Loose Parameters (Recommended for simple actions)
Define parameters directly as function arguments:

```python
@controller.action('Click element')
def click_element(index: int, browser_session: BrowserSession) -> ActionResult:
    # index is the action parameter
    # browser_session is a special injected parameter
    return ActionResult(extracted_content=f"Clicked element {index}")
```

### Important Rules

1. **No **kwargs allowed**: Actions must use explicit parameters only
2. **Return ActionResult**: All actions should return an `ActionResult` instance
3. **Special parameters come after action parameters**: Always define your action parameters first, then any special parameters you need
4. **Type hints are recommended**: They help with validation and IDE support

## Using Custom Actions with multiple agents

You can use the same controller for multiple agents.

```python
controller = Controller()

# ... register actions to the controller

agent = Agent(
    task="Go to website X and find the latest news",
    llm=llm,
    controller=controller
)

# Run the agent
await agent.run()

agent2 = Agent(
    task="Go to website Y and find the latest news",
    llm=llm,
    controller=controller
)

await agent2.run()
```

<Note>
  The controller is stateless and can be used to register multiple actions and
  multiple agents.
</Note>



## Exclude functions
If you want less actions to be used by the agent, you can exclude them from the controller.
```python
controller = Controller(exclude_actions=['open_tab', 'search_google'])
```

For more examples like file upload or notifications, visit [examples/custom-functions](https://github.com/browser-use/browser-use/tree/main/examples/custom-functions).
